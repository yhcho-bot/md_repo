// Generated by gencpp from file md/monitor_msg.msg
// DO NOT EDIT!


#ifndef MD_MESSAGE_MONITOR_MSG_H
#define MD_MESSAGE_MONITOR_MSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace md
{
template <class ContainerAllocator>
struct monitor_msg_
{
  typedef monitor_msg_<ContainerAllocator> Type;

  monitor_msg_()
    : lPosiX(0)
    , lPosiY(0)
    , sTheta(0)
    , sRealLinearVel(0)
    , sRealAngularVel(0)
    , sVoltIn(0)
    , sLeftMotCur(0)
    , sRightMotCur(0)
    , byUS1(0)
    , byUS2(0)
    , byUS3(0)
    , byUS4(0)
    , byPlatStatus(0)
    , byDocStatus(0)
    , byLeftMotStatus(0)
    , byRightMotStatus(0)
    , lLeftMotPosi(0)
    , lRightMotPosi(0)
    , byLeftIOMonitor(0)
    , byRightIOMonitor(0)  {
    }
  monitor_msg_(const ContainerAllocator& _alloc)
    : lPosiX(0)
    , lPosiY(0)
    , sTheta(0)
    , sRealLinearVel(0)
    , sRealAngularVel(0)
    , sVoltIn(0)
    , sLeftMotCur(0)
    , sRightMotCur(0)
    , byUS1(0)
    , byUS2(0)
    , byUS3(0)
    , byUS4(0)
    , byPlatStatus(0)
    , byDocStatus(0)
    , byLeftMotStatus(0)
    , byRightMotStatus(0)
    , lLeftMotPosi(0)
    , lRightMotPosi(0)
    , byLeftIOMonitor(0)
    , byRightIOMonitor(0)  {
  (void)_alloc;
    }



   typedef int32_t _lPosiX_type;
  _lPosiX_type lPosiX;

   typedef int32_t _lPosiY_type;
  _lPosiY_type lPosiY;

   typedef int16_t _sTheta_type;
  _sTheta_type sTheta;

   typedef int16_t _sRealLinearVel_type;
  _sRealLinearVel_type sRealLinearVel;

   typedef int16_t _sRealAngularVel_type;
  _sRealAngularVel_type sRealAngularVel;

   typedef int16_t _sVoltIn_type;
  _sVoltIn_type sVoltIn;

   typedef int16_t _sLeftMotCur_type;
  _sLeftMotCur_type sLeftMotCur;

   typedef int16_t _sRightMotCur_type;
  _sRightMotCur_type sRightMotCur;

   typedef uint8_t _byUS1_type;
  _byUS1_type byUS1;

   typedef uint8_t _byUS2_type;
  _byUS2_type byUS2;

   typedef uint8_t _byUS3_type;
  _byUS3_type byUS3;

   typedef uint8_t _byUS4_type;
  _byUS4_type byUS4;

   typedef uint8_t _byPlatStatus_type;
  _byPlatStatus_type byPlatStatus;

   typedef uint8_t _byDocStatus_type;
  _byDocStatus_type byDocStatus;

   typedef uint8_t _byLeftMotStatus_type;
  _byLeftMotStatus_type byLeftMotStatus;

   typedef uint8_t _byRightMotStatus_type;
  _byRightMotStatus_type byRightMotStatus;

   typedef int32_t _lLeftMotPosi_type;
  _lLeftMotPosi_type lLeftMotPosi;

   typedef int32_t _lRightMotPosi_type;
  _lRightMotPosi_type lRightMotPosi;

   typedef uint8_t _byLeftIOMonitor_type;
  _byLeftIOMonitor_type byLeftIOMonitor;

   typedef uint8_t _byRightIOMonitor_type;
  _byRightIOMonitor_type byRightIOMonitor;





  typedef boost::shared_ptr< ::md::monitor_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::md::monitor_msg_<ContainerAllocator> const> ConstPtr;

}; // struct monitor_msg_

typedef ::md::monitor_msg_<std::allocator<void> > monitor_msg;

typedef boost::shared_ptr< ::md::monitor_msg > monitor_msgPtr;
typedef boost::shared_ptr< ::md::monitor_msg const> monitor_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::md::monitor_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::md::monitor_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::md::monitor_msg_<ContainerAllocator1> & lhs, const ::md::monitor_msg_<ContainerAllocator2> & rhs)
{
  return lhs.lPosiX == rhs.lPosiX &&
    lhs.lPosiY == rhs.lPosiY &&
    lhs.sTheta == rhs.sTheta &&
    lhs.sRealLinearVel == rhs.sRealLinearVel &&
    lhs.sRealAngularVel == rhs.sRealAngularVel &&
    lhs.sVoltIn == rhs.sVoltIn &&
    lhs.sLeftMotCur == rhs.sLeftMotCur &&
    lhs.sRightMotCur == rhs.sRightMotCur &&
    lhs.byUS1 == rhs.byUS1 &&
    lhs.byUS2 == rhs.byUS2 &&
    lhs.byUS3 == rhs.byUS3 &&
    lhs.byUS4 == rhs.byUS4 &&
    lhs.byPlatStatus == rhs.byPlatStatus &&
    lhs.byDocStatus == rhs.byDocStatus &&
    lhs.byLeftMotStatus == rhs.byLeftMotStatus &&
    lhs.byRightMotStatus == rhs.byRightMotStatus &&
    lhs.lLeftMotPosi == rhs.lLeftMotPosi &&
    lhs.lRightMotPosi == rhs.lRightMotPosi &&
    lhs.byLeftIOMonitor == rhs.byLeftIOMonitor &&
    lhs.byRightIOMonitor == rhs.byRightIOMonitor;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::md::monitor_msg_<ContainerAllocator1> & lhs, const ::md::monitor_msg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace md

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::md::monitor_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::md::monitor_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::md::monitor_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::md::monitor_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::md::monitor_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::md::monitor_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::md::monitor_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "265bab62db87a50551604683361197df";
  }

  static const char* value(const ::md::monitor_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x265bab62db87a505ULL;
  static const uint64_t static_value2 = 0x51604683361197dfULL;
};

template<class ContainerAllocator>
struct DataType< ::md::monitor_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "md/monitor_msg";
  }

  static const char* value(const ::md::monitor_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::md::monitor_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 lPosiX \n"
"int32 lPosiY\n"
"int16 sTheta\n"
"int16 sRealLinearVel\n"
"int16 sRealAngularVel\n"
"int16 sVoltIn\n"
"int16 sLeftMotCur\n"
"int16 sRightMotCur\n"
"uint8 byUS1\n"
"uint8 byUS2\n"
"uint8 byUS3\n"
"uint8 byUS4\n"
"uint8 byPlatStatus\n"
"uint8 byDocStatus\n"
"uint8 byLeftMotStatus\n"
"uint8 byRightMotStatus\n"
"int32 lLeftMotPosi\n"
"int32 lRightMotPosi\n"
"uint8 byLeftIOMonitor\n"
"uint8 byRightIOMonitor\n"
;
  }

  static const char* value(const ::md::monitor_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::md::monitor_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.lPosiX);
      stream.next(m.lPosiY);
      stream.next(m.sTheta);
      stream.next(m.sRealLinearVel);
      stream.next(m.sRealAngularVel);
      stream.next(m.sVoltIn);
      stream.next(m.sLeftMotCur);
      stream.next(m.sRightMotCur);
      stream.next(m.byUS1);
      stream.next(m.byUS2);
      stream.next(m.byUS3);
      stream.next(m.byUS4);
      stream.next(m.byPlatStatus);
      stream.next(m.byDocStatus);
      stream.next(m.byLeftMotStatus);
      stream.next(m.byRightMotStatus);
      stream.next(m.lLeftMotPosi);
      stream.next(m.lRightMotPosi);
      stream.next(m.byLeftIOMonitor);
      stream.next(m.byRightIOMonitor);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct monitor_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::md::monitor_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::md::monitor_msg_<ContainerAllocator>& v)
  {
    s << indent << "lPosiX: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lPosiX);
    s << indent << "lPosiY: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lPosiY);
    s << indent << "sTheta: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sTheta);
    s << indent << "sRealLinearVel: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sRealLinearVel);
    s << indent << "sRealAngularVel: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sRealAngularVel);
    s << indent << "sVoltIn: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sVoltIn);
    s << indent << "sLeftMotCur: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sLeftMotCur);
    s << indent << "sRightMotCur: ";
    Printer<int16_t>::stream(s, indent + "  ", v.sRightMotCur);
    s << indent << "byUS1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byUS1);
    s << indent << "byUS2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byUS2);
    s << indent << "byUS3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byUS3);
    s << indent << "byUS4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byUS4);
    s << indent << "byPlatStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byPlatStatus);
    s << indent << "byDocStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byDocStatus);
    s << indent << "byLeftMotStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byLeftMotStatus);
    s << indent << "byRightMotStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byRightMotStatus);
    s << indent << "lLeftMotPosi: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lLeftMotPosi);
    s << indent << "lRightMotPosi: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lRightMotPosi);
    s << indent << "byLeftIOMonitor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byLeftIOMonitor);
    s << indent << "byRightIOMonitor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.byRightIOMonitor);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MD_MESSAGE_MONITOR_MSG_H
